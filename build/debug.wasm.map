{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/stub.ts","~lib/util/error.ts"],"names":[],"mappings":"gNCYoB,EAAlB,EACkB,EAAsB,EAAtB,CAA4B,EAA7B,CAAyC,E,EAAD,CAAzC,CAAhB,EACI,EAAY,EAAZ,CAAJ,EAC4B,EAAY,EAAZ,CAAwB,IAAxB,CAAmC,I,EAAD,CAAnC,CAAgD,EAAvD,CAAlB,EACsB,E,EAAa,E,OAAjB,CAAlB,EACgB,EAAZ,EAA2B,EAA3B,CAAJ,EACkB,EAAZ,EAA2B,EAA3B,CAAJ,EAAkC,IAG7B,EAAT,K,YAWI,EAAO,MAAP,CAAJ,EAA0C,E,WAC9B,EAAZ,EACU,EAAS,EAAT,CAAV,EACkB,EAAY,E,EATrB,EAAO,EAAP,CAAwB,EAAxB,CAAoC,E,EAAD,CAApC,CAAgD,EAAjD,CAAP,GASA,EACgB,EAAM,EAAN,CAAhB,EACA,EAAe,EAAf,EACO,EAAP,I,0CA+CI,EAAO,MAAP,CAAJ,EAA2C,E,YACzB,EAAkB,EAAlB,CAAR,EAAV,EACgC,EAAM,EAAzB,CAAb,EACA,EAAgB,EAAhB,EACA,EAAiB,EAAjB,EACA,EAAc,EAAd,EACA,EAAgB,EAAhB,EACO,EAAM,EAAN,CAAP,IAqBO,EAAP,I","sourceRoot":"./debug","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \"./common\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === A minimal runtime stub ===\n\n// @ts-ignore: decorator\n@lazy let startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n// @ts-ignore: decorator\n@lazy let offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  let pagesBefore = memory.size();\n  let maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@inline function computeSize(size: usize): usize {\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let block = changetype<BLOCK>(offset);\n  let ptr = offset + BLOCK_OVERHEAD;\n  let payloadSize = computeSize(size);\n  maybeGrowMemory(ptr + payloadSize);\n  block.mmInfo = payloadSize;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  let actualSize = block.mmInfo;\n  let isLast = ptr + actualSize == offset;\n  let payloadSize = computeSize(size);\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n      maybeGrowMemory(ptr + payloadSize);\n      block.mmInfo = payloadSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\n      memory.copy(newPtr, ptr, actualSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + payloadSize;\n    block.mmInfo = payloadSize;\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __new(size: usize, id: u32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let ptr = __alloc(OBJECT_OVERHEAD + size);\n  let object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\n  object.gcInfo = 0;\n  object.gcInfo2 = 0;\n  object.rtId = id;\n  object.rtSize = <u32>size;\n  return ptr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __renew(oldPtr: usize, size: usize): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\n  return newPtr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  // nop\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n"]}